class Request < ApplicationRecord
  # related to usage of active storage, removes from both tables in databasesaysay
  has_one_attached :input_image, dependent: :destroy
  has_one_attached :output_audio, dependent: :destroy

  # TODO: figure out how to validate size
  validates :input_image, presence: true
  validate :input_image_mime_type

  after_create :convert_image_to_audio

  def convert_image_to_audio
    unique_intermediate_name = "intermediate#{id}"
    # Path to input image needed to use tesseract
    # https://edgeguides.rubyonrails.org/active_storage_overview.html#downloading-files
    input_image.open do |file|
      puts "Running tesseract command: tesseract -l eng #{file.path} #{unique_intermediate_name}"

      # https://www.cloudsavvyit.com/8151/how-to-convert-images-to-text-on-the-linux-command-line-with-ocr/
      `tesseract -l eng #{file.path} #{unique_intermediate_name}`
    end

    # File generated by tesseract (appends .txt to the intermediate name)
    intermediate_file = "#{unique_intermediate_name}.txt"
    self.intermediate_text = File.read(intermediate_file)

    # text to audio
    unique_output_name = "output#{id}.mp3"
    # command to say file with -f, write audio into a file using ffmpeg
    # https://askubuntu.com/a/178768
    `espeak -s 125 -v en-us+f2 -f #{intermediate_file} --stdout | ffmpeg -i - -ar 44100 -ac 2 -ab 192k -f mp3 #{unique_output_name}`

    # save output audio from a file to the database
    # https://edgeguides.rubyonrails.org/active_storage_overview.html#attaching-file-io-objects
    output_audio.attach(io: File.open(unique_output_name), filename: unique_output_name)

    # Clean up (We don't need the intermediate file)
    File.delete(intermediate_file)
    File.delete(unique_output_name)

    save
  end

  private

  def input_image_mime_type
    return unless input_image.attached?

    return if input_image.content_type == 'image/png'

    errors.add(:input_image, 'Must be a png')
  end
end